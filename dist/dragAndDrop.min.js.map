{"version":3,"file":"dragAndDrop.min.js","mappings":"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","sources":["webpack://draganddrop/./src/dragAndDrop.ts","webpack://draganddrop/webpack/startup"],"sourcesContent":["const defaultDraggingClass = \"dragging-item\";\n\nabstract class BaseDragAndDrop {\n  static overActiveDragAndDropBox: HTMLElement | null = null;\n  static draggingItem: HTMLElement | null = null;\n  static initialStartDnDList: HTMLElement | null = null;\n  static draggingClassMap: Map<HTMLElement, string> = new Map();\n  static onDragStartMap: Map<HTMLElement, Function> = new Map();\n  static onDragOverMap: Map<HTMLElement, Function> = new Map();\n  static onDragEndMap: Map<HTMLElement, Function> = new Map();\n}\n\ninterface DnD {\n  init: () => void;\n  dragStartHandler: (element: HTMLElement) => void;\n  dragOverHandler: (e: DragEvent) => void;\n  dragEndHandler: (e: DragEvent, element: HTMLElement) => void;\n}\n\nclass DragAndDrop extends BaseDragAndDrop implements DnD {\n  private dragAndDropList: HTMLElement;\n  private isInit: boolean;\n  private dragAndDropItems: HTMLElement[];\n  private isRemoveItemLogic: boolean;\n  private allowDnDFromSelectors: string[];\n\n  constructor(\n    dragAndDropList: HTMLElement,\n    draggingClass: string,\n    removeItem: boolean,\n    allowDnDFromSelectors: string[],\n    onDragStart: (e?: DragEvent) => void,\n    onDragOver: (e?: DragEvent) => void,\n    onDragEnd: (e?: DragEvent) => void\n  ) {\n    super();\n    this.dragAndDropList = dragAndDropList;\n    this.isInit = false;\n    this.dragAndDropItems = Array.from(\n      this.dragAndDropList.children\n    ) as HTMLElement[];\n    this.allowDnDFromSelectors = allowDnDFromSelectors;\n    this.isRemoveItemLogic = removeItem;\n    DragAndDrop.draggingClassMap.set(dragAndDropList, draggingClass);\n    DragAndDrop.onDragStartMap.set(dragAndDropList, onDragStart);\n    DragAndDrop.onDragOverMap.set(dragAndDropList, onDragOver);\n    DragAndDrop.onDragEndMap.set(dragAndDropList, onDragEnd);\n  }\n\n  init() {\n    if (!this.isInit) {\n      this.isInit = true;\n      this.dragAndDropItems.forEach((dndItem) => {\n        dndItem.setAttribute(\"draggable\", \"true\");\n        dndItem.addEventListener(\"dragstart\", () =>\n          this.dragStartHandler(dndItem)\n        );\n        dndItem.addEventListener(\"dragover\", (e: DragEvent) =>\n          this.dragOverHandler(e)\n        );\n        dndItem.addEventListener(\"dragend\", (e: DragEvent) =>\n          this.dragEndHandler(e, dndItem)\n        );\n      });\n      this.dragAndDropList.addEventListener(\"dragenter\", (e: DragEvent) =>\n        this.dragEnterHandler(e)\n      );\n      this.dragAndDropList.addEventListener(\"dragover\", (e: DragEvent) =>\n        this.dragOverHandler(e)\n      );\n    }\n  }\n\n  dragStartHandler(item: HTMLElement) {\n    DragAndDrop.draggingItem = item;\n    if (item.parentElement) {\n      const draggingClass = DragAndDrop.draggingClassMap.get(\n        item.parentElement\n      );\n      if (draggingClass) {\n        item.classList.add(draggingClass);\n      }\n    }\n    if (this.dragAndDropList.contains(item)) {\n      DragAndDrop.initialStartDnDList = this.dragAndDropList;\n      DragAndDrop.overActiveDragAndDropBox = this.dragAndDropList;\n    }\n    if (item.parentElement) {\n      const onDragStartFunc = DragAndDrop.onDragStartMap.get(\n        item.parentElement\n      );\n      if (onDragStartFunc) {\n        onDragStartFunc();\n      }\n    }\n  }\n\n  dragOverHandler(e: DragEvent) {\n    e.preventDefault();\n    if (e.dataTransfer) {\n      e.dataTransfer.dropEffect = \"move\";\n    }\n    let activeDndSelector = this.dragAndDropList;\n    if (DragAndDrop.overActiveDragAndDropBox) {\n      activeDndSelector = DragAndDrop.overActiveDragAndDropBox;\n    }\n    const dndItems = Array.from(activeDndSelector.children) as HTMLElement[];\n    const notDraggingItems = dndItems.filter(\n      (item) => item !== DragAndDrop.draggingItem\n    ) as HTMLElement[];\n    const nextItem = notDraggingItems.find((item) => {\n      const notDraggingItemRect = item.getBoundingClientRect();\n      return (\n        e.clientY <= notDraggingItemRect.top + notDraggingItemRect.height / 2\n      );\n    }) as Node;\n    if (\n      activeDndSelector &&\n      DragAndDrop.draggingItem &&\n      !DragAndDrop.draggingItem.contains(activeDndSelector)\n    ) {\n      activeDndSelector.insertBefore(DragAndDrop.draggingItem, nextItem);\n    }\n    if (DragAndDrop.draggingItem && DragAndDrop.draggingItem.parentElement) {\n      const onDragOverFunc = DragAndDrop.onDragOverMap.get(\n        DragAndDrop.draggingItem.parentElement\n      );\n      if (onDragOverFunc) {\n        onDragOverFunc();\n      }\n    }\n  }\n\n  dragEndHandler(e: DragEvent, item: HTMLElement) {\n    if (\n      this.isRemoveItemLogic &&\n      DragAndDrop.overActiveDragAndDropBox === this.dragAndDropList\n    ) {\n      const dragAndDropListRect =\n        DragAndDrop.overActiveDragAndDropBox.getBoundingClientRect();\n      if (\n        e.clientY < dragAndDropListRect.top ||\n        e.clientY > dragAndDropListRect.top + dragAndDropListRect.height ||\n        e.clientX < dragAndDropListRect.left ||\n        e.clientX > dragAndDropListRect.left + dragAndDropListRect.width\n      ) {\n        item.parentNode?.removeChild(item);\n      }\n    }\n    if (item.parentElement) {\n      const parentDraggingClass = DragAndDrop.draggingClassMap.get(\n        item.parentElement\n      );\n      if (parentDraggingClass) {\n        item.classList.remove(parentDraggingClass);\n      }\n    }\n    const dndListDraggingClass = DragAndDrop.draggingClassMap.get(\n      this.dragAndDropList\n    );\n    if (dndListDraggingClass) {\n      item.classList.remove(dndListDraggingClass);\n    }\n    DragAndDrop.draggingItem = null;\n    DragAndDrop.initialStartDnDList = null;\n    if (item.parentElement) {\n      const onDragEndFunc = DragAndDrop.onDragEndMap.get(item.parentElement);\n      if (onDragEndFunc) {\n        onDragEndFunc();\n      }\n    }\n  }\n\n  dragEnterHandler(e: DragEvent) {\n    let allowAssignDnDBox = false;\n    for (const allowDndElem of this.allowDnDFromSelectors) {\n      if (\n        DragAndDrop.overActiveDragAndDropBox?.classList.contains(allowDndElem)\n      ) {\n        allowAssignDnDBox = true;\n        break;\n      }\n    }\n    let isInitDnDList = false;\n    if (DragAndDrop.initialStartDnDList) {\n      isInitDnDList = true;\n      for (const initDnDListClass of Array.from(\n        DragAndDrop.initialStartDnDList.classList\n      )) {\n        if (\n          !(e.currentTarget as HTMLElement)?.classList.contains(\n            initDnDListClass\n          )\n        ) {\n          isInitDnDList = false;\n          break;\n        }\n      }\n    }\n    if (!allowAssignDnDBox && !isInitDnDList) {\n      return;\n    }\n    if (DragAndDrop.overActiveDragAndDropBox) {\n      const overActiveDnDBoxDraggingClass = DragAndDrop.draggingClassMap.get(\n        DragAndDrop.overActiveDragAndDropBox\n      );\n      if (overActiveDnDBoxDraggingClass) {\n        DragAndDrop.draggingItem?.classList.remove(\n          overActiveDnDBoxDraggingClass\n        );\n      }\n    }\n    DragAndDrop.overActiveDragAndDropBox = <HTMLElement>e.currentTarget;\n    if (DragAndDrop.overActiveDragAndDropBox) {\n      const overActiveDnDBoxDraggingClass = DragAndDrop.draggingClassMap.get(\n        DragAndDrop.overActiveDragAndDropBox\n      );\n      if (overActiveDnDBoxDraggingClass) {\n        DragAndDrop.draggingItem?.classList.add(overActiveDnDBoxDraggingClass);\n      }\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElement {\n    dragAndDrop(settings?: {\n      draggingClass?: string;\n      removeItem?: boolean;\n      allowDnDFromSelectors?: string | string[];\n      onDragStart?: (e?: DragEvent) => void;\n      onDragOver?: (e?: DragEvent) => void;\n      onDragEnd?: (e?: DragEvent) => void;\n    }): void;\n  }\n}\n\nHTMLElement.prototype.dragAndDrop = function (settings) {\n  const settingsToSet = {\n    draggingClass: settings?.draggingClass\n      ? settings.draggingClass\n      : defaultDraggingClass,\n    removeItem: settings?.removeItem ? settings.removeItem : false,\n    allowDnDFromSelectors: settings?.allowDnDFromSelectors\n      ? Array.isArray(settings.allowDnDFromSelectors)\n        ? [...settings.allowDnDFromSelectors]\n        : [settings.allowDnDFromSelectors]\n      : [],\n    onDragStart: settings?.onDragStart ? settings.onDragStart : () => {},\n    onDragOver: settings?.onDragOver ? settings.onDragOver : () => {},\n    onDragEnd: settings?.onDragEnd ? settings.onDragEnd : () => {},\n  };\n  const dragAndDrop = new DragAndDrop(\n    this,\n    settingsToSet.draggingClass,\n    settingsToSet.removeItem,\n    settingsToSet.allowDnDFromSelectors,\n    settingsToSet.onDragStart,\n    settingsToSet.onDragOver,\n    settingsToSet.onDragEnd\n  );\n  dragAndDrop.init();\n};\n\nexport {};\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[410](0, __webpack_exports__);\n"],"names":["dragAndDropList","draggingClass","removeItem","allowDnDFromSelectors","onDragStart","onDragOver","onDragEnd","isInit","dragAndDropItems","Array","from","children","isRemoveItemLogic","DragAndDrop","draggingClassMap","set","onDragStartMap","onDragOverMap","onDragEndMap","init","this","forEach","dndItem","setAttribute","addEventListener","dragStartHandler","e","dragOverHandler","dragEndHandler","dragEnterHandler","item","draggingItem","parentElement","get","classList","add","contains","initialStartDnDList","overActiveDragAndDropBox","onDragStartFunc","preventDefault","dataTransfer","dropEffect","activeDndSelector","nextItem","filter","find","notDraggingItemRect","getBoundingClientRect","clientY","top","height","insertBefore","onDragOverFunc","dragAndDropListRect","clientX","left","width","parentNode","removeChild","parentDraggingClass","remove","dndListDraggingClass","onDragEndFunc","allowAssignDnDBox","allowDndElem","overActiveDnDBoxDraggingClass","isInitDnDList","initDnDListClass","currentTarget","Map","HTMLElement","prototype","dragAndDrop","settings","settingsToSet","isArray"],"sourceRoot":""}